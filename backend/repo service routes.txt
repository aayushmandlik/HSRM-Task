# routers/user_routes.py
from fastapi import APIRouter, HTTPException, Depends
from fastapi.security import OAuth2PasswordRequestForm
from schemas.user_schema import UserLogin, UserRegister, UserOut
from schemas.token_schema import TokenResponse, TokenPayload
from core.security import get_current_user
from services import user_service

router = APIRouter(prefix='/api/users', tags=['User'])

@router.post("/register", response_model=UserOut)
async def register(user: UserRegister):
    return await user_service.register_user(user)

@router.post("/login", response_model=TokenResponse)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    return await user_service.login_user(form_data)

@router.get("/profile")
async def get_profile(current_user: TokenPayload = Depends(get_current_user)):
    return {"message": "Welcome", "user": current_user.dict()}


# services/user_service.py
from fastapi import HTTPException, Depends
from fastapi.security import OAuth2PasswordRequestForm
from schemas.user_schema import UserRegister, UserOut
from schemas.token_schema import TokenResponse
from repositories import user_repository
from core.security import create_access_token, create_refresh_token
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def hash_password(password: str):
    return pwd_context.hash(password)

async def register_user(user: UserRegister):
    existing = await user_repository.find_user_by_email(user.email)
    if existing:
        raise HTTPException(status_code=400, detail="User already exists")

    hashed = hash_password(user.password)
    user_dict = {**user.dict(), "password": hashed, "role": "user"}
    new_user = await user_repository.insert_user(user_dict)
    return UserOut(
        id=str(new_user["_id"]),
        name=new_user["name"],
        email=new_user["email"],
        message="User Registered Successfully"
    )

async def login_user(form_data: OAuth2PasswordRequestForm):
    record = await user_repository.find_user_by_email(form_data.username)
    if not record:
        raise HTTPException(status_code=404, detail="Email Not Found")
    if not verify_password(form_data.password, record["password"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    payload = {
        "user_id": str(record["_id"]),
        "email": record["email"],
        "role": record.get("role", "user"),
        "name": record["name"]
    }

    return TokenResponse(
        access_token=create_access_token(payload),
        refresh_token=create_refresh_token(payload),
        token_type="bearer",
        email=record["email"],
        name=record["name"],
        role=record.get("role", "user"),
        user_id=str(record["_id"])
    )


# repositories/user_repository.py
from databases.database import users_collection

async def find_user_by_email(email: str):
    return await users_collection.find_one({"email": email})

async def insert_user(user_dict: dict):
    result = await users_collection.insert_one(user_dict)
    return await users_collection.find_one({"_id": result.inserted_id})


---------

# routers/admin_routes.py
from fastapi import APIRouter, HTTPException, Depends
from schemas.admin_schema import AdminRegister, AdminLogin
from schemas.token_schema import TokenResponse, TokenPayload
from services import admin_service
from typing import List

router = APIRouter(prefix="/api/admin", tags=["Admin"])

@router.post("/register")
async def register(admin: AdminRegister):
    return await admin_service.register_admin(admin)

@router.post("/login", response_model=TokenResponse)
async def login(admin: AdminLogin):
    return await admin_service.login_admin(admin)

@router.get("/dashboard")
async def dashboard(current_admin: TokenPayload = Depends(admin_service.require_admin)):
    return await admin_service.admin_dashboard(current_admin)

@router.get("/getallusers", response_model=List[TokenPayload])
async def get_all_users(current_admin: TokenPayload = Depends(admin_service.require_admin)):
    return await admin_service.get_all_users()

@router.get("/getallregistereduseradmin", response_model=List[TokenPayload])
async def get_all_registered(current_admin: TokenPayload = Depends(admin_service.require_admin)):
    return await admin_service.get_all_registered_users_and_admins()


# services/admin_service.py
from fastapi import HTTPException
from core.config import ADMIN_VERIFICATION_CODE
from passlib.context import CryptContext
from repositories import admin_repository, user_repository
from core.security import create_access_token, create_refresh_token, require_admin
from schemas.admin_schema import AdminRegister, AdminLogin
from schemas.token_schema import TokenResponse

pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def hash_password(password: str):
    return pwd_context.hash(password)

async def register_admin(admin: AdminRegister):
    if admin.code != ADMIN_VERIFICATION_CODE:
        raise HTTPException(status_code=403, detail="Invalid verification code")

    existing = await admin_repository.find_admin_by_email(admin.email)
    if existing:
        raise HTTPException(status_code=400, detail="Admin already exists")

    hashed = hash_password(admin.password)
    await admin_repository.insert_admin({**admin.dict(), "password": hashed})
    return {"message": "Admin registered"}

async def login_admin(admin: AdminLogin):
    record = await admin_repository.find_admin_by_email(admin.email)
    if not record:
        raise HTTPException(status_code=404, detail="Email Not Found")
    if not verify_password(admin.password, record["password"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    payload = {
        "user_id": str(record["_id"]),
        "email": record["email"],
        "role": "admin",
        "name": record["name"]
    }
    return TokenResponse(
        access_token=create_access_token(payload),
        refresh_token=create_refresh_token(payload),
        token_type="bearer",
        role="admin",
        email=record["email"],
        name=record["name"],
        user_id=str(record["_id"])
    )

async def admin_dashboard(current_admin):
    return {"message": f"Welcome Admin {current_admin['email']}"}

async def get_all_users():
    users_cursor = user_repository.find_all_users()
    users = []
    async for user in users_cursor:
        users.append({
            "user_id": str(user["_id"]),
            "email": user["email"],
            "name": user["name"],
            "role": user.get("role", "user")
        })
    return users

async def get_all_registered_users_and_admins():
    users_cursor = user_repository.find_all_users()
    admins_cursor = admin_repository.find_all_admins()
    combined = []

    async for user in users_cursor:
        combined.append({
            "user_id": str(user["_id"]),
            "email": user["email"],
            "name": user["name"],
            "role": user.get("role", "user")
        })

    async for admin in admins_cursor:
        combined.append({
            "user_id": str(admin["_id"]),
            "email": admin["email"],
            "name": admin["name"],
            "role": admin.get("role", "admin")
        })

    return combined


# repositories/admin_repository.py
from databases.database import admins_collection

async def find_admin_by_email(email: str):
    return await admins_collection.find_one({"email": email})

async def insert_admin(admin_dict: dict):
    return await admins_collection.insert_one(admin_dict)

async def find_all_admins():
    return admins_collection.find()


# repositories/user_repository.py
from databases.database import users_collection

async def find_user_by_email(email: str):
    return await users_collection.find_one({"email": email})

async def insert_user(user_dict: dict):
    result = await users_collection.insert_one(user_dict)
    return await users_collection.find_one({"_id": result.inserted_id})

async def find_all_users():
    return users_collection.find()


------------

# routers/employee_routes.py
from fastapi import APIRouter, Depends, HTTPException
from schemas.employee_schema import EmployeeCreate, EmployeeUpdate, EmployeeOut
from core.security import require_admin, get_current_user, TokenPayload
from services import employee_service
from typing import List

router = APIRouter(prefix="/employee", tags=["Employee"])

@router.post("/create", response_model=EmployeeOut)
async def create_employee(data: EmployeeCreate, current_admin: TokenPayload = Depends(require_admin)):
    return await employee_service.create_employee(data)

@router.get("/getall", response_model=List[EmployeeOut])
async def get_all_employees(current_admin: TokenPayload = Depends(require_admin)):
    return await employee_service.get_all_employees()

@router.get("/{user_id}", response_model=EmployeeOut)
async def get_employee(user_id: str, current_user: TokenPayload = Depends(get_current_user)):
    return await employee_service.get_employee(user_id, current_user)

@router.put("/{emp_code}", response_model=EmployeeOut)
async def update_employee(emp_code: str, data: EmployeeUpdate, current_admin: TokenPayload = Depends(require_admin)):
    return await employee_service.update_employee(emp_code, data)

@router.delete("/{emp_code}", response_model=EmployeeOut)
async def delete_employee(emp_code: str, current_admin: TokenPayload = Depends(require_admin)):
    return await employee_service.delete_employee(emp_code)


# services/employee_service.py
from fastapi import HTTPException
from core.security import TokenPayload
from schemas.employee_schema import EmployeeCreate, EmployeeUpdate
from repositories import employee_repository, user_repository, admin_repository

async def create_employee(data: EmployeeCreate):
    user = await user_repository.find_user_by_email(data.email)
    admin = await admin_repository.find_admin_by_email(data.email)
    if not user and not admin:
        raise HTTPException(status_code=400, detail="User with this email does not exist")

    existing = await employee_repository.find_employee_by_email(data.email)
    if existing:
        raise HTTPException(status_code=400, detail="Employee with this email already exists")

    employee_dict = data.dict()
    if user:
        employee_dict["user_id"] = str(user["_id"])
    elif admin:
        employee_dict["user_id"] = str(admin["_id"])

    result = await employee_repository.insert_employee(employee_dict)
    return result

async def get_all_employees():
    employees_cursor = employee_repository.find_all_employees()
    employees = []
    async for emp in employees_cursor:
        emp["_id"] = str(emp["_id"])
        employees.append(emp)
    return employees

async def get_employee(user_id: str, current_user: TokenPayload):
    if current_user.role != "admin" and current_user.user_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    emp = await employee_repository.find_employee_by_user_id(user_id)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    emp["_id"] = str(emp["_id"])
    return emp

async def update_employee(emp_code: str, data: EmployeeUpdate):
    updated = await employee_repository.update_employee_by_code(emp_code, data)
    return updated

async def delete_employee(emp_code: str):
    deleted = await employee_repository.delete_employee_by_code(emp_code)
    return deleted


# repositories/employee_repository.py
from databases.database import employee_collection
from schemas.employee_schema import EmployeeUpdate

async def find_employee_by_email(email: str):
    return await employee_collection.find_one({"email": email})

async def insert_employee(employee_dict: dict):
    result = await employee_collection.insert_one(employee_dict)
    employee_dict["_id"] = str(result.inserted_id)
    return employee_dict

async def find_all_employees():
    return employee_collection.find()

async def find_employee_by_user_id(user_id: str):
    return await employee_collection.find_one({"user_id": user_id})

async def update_employee_by_code(emp_code: str, data: EmployeeUpdate):
    result = await employee_collection.update_one({"emp_code": emp_code}, {"$set": data.dict(exclude_unset=True)})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Employee not found")
    updated = await employee_collection.find_one({"emp_code": emp_code})
    if not updated:
        raise HTTPException(status_code=500, detail="Failed to retrieve updated employee")
    updated["_id"] = str(updated["_id"])
    return updated

async def delete_employee_by_code(emp_code: str):
    employee = await employee_collection.find_one({"emp_code": emp_code})
    if not employee:
        raise HTTPException(status_code=404, detail="Employee not found")
    await employee_collection.delete_one({"emp_code": emp_code})
    employee["_id"] = str(employee["_id"])
    return employee


---------------------------------------

# routers/leave_routes.py
from fastapi import APIRouter, Depends
from schemas.leave_schema import LeaveCreate, LeaveUpdate, LeaveResponse
from services import leave_service
from core.security import require_admin_or_user, TokenPayload
from typing import List

router = APIRouter(prefix="/Emp_leave", tags=["Employee Leave"])

@router.post("/request", response_model=LeaveResponse)
async def request_leave(leave: LeaveCreate, current_user: TokenPayload = Depends(require_admin_or_user)):
    return await leave_service.request_leave(leave, current_user)

@router.get("/my-requests", response_model=List[LeaveResponse])
async def get_my_leave_requests(current_user: TokenPayload = Depends(require_admin_or_user)):
    return await leave_service.get_my_leave_requests(current_user)

@router.patch("/{leave_id}", response_model=LeaveResponse)
async def update_leave_request(leave_id: str, update_data: LeaveUpdate, current_user: TokenPayload = Depends(require_admin_or_user)):
    return await leave_service.update_leave_request(leave_id, update_data, current_user)

@router.delete("/{leave_id}", response_model=LeaveResponse)
async def delete_leave_request(leave_id: str, current_user: TokenPayload = Depends(require_admin_or_user)):
    return await leave_service.delete_leave_request(leave_id, current_user)


# services/leave_service.py
from fastapi import HTTPException, status
from bson import ObjectId
from datetime import datetime
from schemas.leave_schema import LeaveCreate, LeaveUpdate, LeaveStatus
from repositories import leave_repository, employee_repository

async def calculate_leave_days(start_date, end_date):
    return (end_date - start_date).days + 1

async def get_employee_leave_balance(employee_id: str, leave_type: str = None):
    return await leave_repository.calculate_balance(employee_id, leave_type)

async def request_leave(leave: LeaveCreate, current_user):
    if leave.start_date > leave.end_date:
        raise HTTPException(status_code=400, detail="End date must be after start date")

    days = await calculate_leave_days(leave.start_date, leave.end_date)
    if leave.leave_type not in ["Medical", "Casual", "Annual"]:
        raise HTTPException(status_code=400, detail="Invalid leave type")

    _, remaining_leaves = await get_employee_leave_balance(current_user.user_id, leave.leave_type)
    if remaining_leaves < days:
        raise HTTPException(status_code=400, detail=f"Insufficient {leave.leave_type} balance")

    emp = await employee_repository.find_employee_by_user_id(current_user.user_id)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")

    leave_dict = leave.dict()
    leave_dict.update({
        "employee_id": current_user.user_id,
        "employee_name": emp.get("name", "Unknown"),
        "status": LeaveStatus.PENDING,
        "days": days,
        "created_at": datetime.utcnow(),
        "updated_at": datetime.utcnow(),
        "leave_balances": await get_employee_leave_balance(current_user.user_id),
        "approved_by": None
    })
    return await leave_repository.insert_leave(leave_dict)

async def get_my_leave_requests(current_user):
    return await leave_repository.get_user_leaves(current_user.user_id)

async def update_leave_request(leave_id: str, update_data: LeaveUpdate, current_user):
    return await leave_repository.update_leave(leave_id, update_data, current_user)

async def delete_leave_request(leave_id: str, current_user):
    return await leave_repository.delete_leave(leave_id, current_user)


# repositories/leave_repository.py
from databases.database import leave_collection
from fastapi import HTTPException
from bson import ObjectId
from datetime import datetime
from schemas.leave_schema import LeaveStatus

async def calculate_balance(employee_id: str, leave_type: str = None):
    initial_balance = {"Medical": 10, "Casual": 10, "Annual": 10}
    if leave_type:
        cursor = leave_collection.find({"employee_id": employee_id, "status": LeaveStatus.APPROVED, "leave_type": leave_type})
        days = [doc["days"] async for doc in cursor]
        total = sum(days)
        return total, max(0, initial_balance[leave_type] - total)
    else:
        balances = {}
        for lt in ["Medical", "Casual", "Annual"]:
            cursor = leave_collection.find({"employee_id": employee_id, "status": LeaveStatus.APPROVED, "leave_type": lt})
            days = [doc["days"] async for doc in cursor]
            balances[lt] = max(0, initial_balance[lt] - sum(days))
        return balances

async def insert_leave(data):
    result = await leave_collection.insert_one(data)
    data["_id"] = str(result.inserted_id)
    return data

async def get_user_leaves(employee_id):
    cursor = leave_collection.find({"employee_id": employee_id})
    leaves = []
    async for leave in cursor:
        leave["_id"] = str(leave["_id"])
        leave["leave_balances"] = await calculate_balance(employee_id)
        leaves.append(leave)
    return leaves

async def update_leave(leave_id, update_data, user):
    try:
        leave = await leave_collection.find_one({"_id": ObjectId(leave_id)})
        if not leave:
            raise HTTPException(status_code=404, detail="Leave not found")
        if leave["employee_id"] != user.user_id:
            raise HTTPException(status_code=403, detail="Unauthorized")
        if leave["status"] != LeaveStatus.PENDING:
            raise HTTPException(status_code=400, detail="Only pending requests can be updated")

        update_fields = {}
        if update_data.start_date and update_data.end_date:
            if update_data.start_date > update_data.end_date:
                raise HTTPException(status_code=400, detail="Invalid date range")
            days = (update_data.end_date - update_data.start_date).days + 1
            _, remaining = await calculate_balance(user.user_id, update_data.leave_type or leave["leave_type"])
            if remaining < days:
                raise HTTPException(status_code=400, detail="Insufficient leave balance")
            update_fields.update({
                "start_date": datetime.combine(update_data.start_date, datetime.min.time()),
                "end_date": datetime.combine(update_data.end_date, datetime.min.time()),
                "days": days
            })
        if update_data.reason:
            update_fields["reason"] = update_data.reason
        if update_data.leave_type:
            update_fields["leave_type"] = update_data.leave_type

        update_fields["updated_at"] = datetime.utcnow()
        update_fields["leave_balances"] = await calculate_balance(user.user_id)

        await leave_collection.update_one({"_id": ObjectId(leave_id)}, {"$set": update_fields})
        updated = await leave_collection.find_one({"_id": ObjectId(leave_id)})
        updated["_id"] = str(updated["_id"])
        return updated

    except Exception:
        raise HTTPException(status_code=400, detail="Invalid leave ID")

async def delete_leave(leave_id, user):
    try:
        leave = await leave_collection.find_one({"_id": ObjectId(leave_id)})
        if not leave:
            raise HTTPException(status_code=404, detail="Leave not found")
        if leave["employee_id"] != user.user_id:
            raise HTTPException(status_code=403, detail="Unauthorized")
        if leave["status"] != LeaveStatus.PENDING:
            raise HTTPException(status_code=400, detail="Only pending can be deleted")
        await leave_collection.delete_one({"_id": ObjectId(leave_id)})
        leave["_id"] = str(leave["_id"])
        return leave
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid leave ID")


------------------------------------------------------------------------------

# routers/attendance_routes.py
from fastapi import APIRouter, Depends, HTTPException
from datetime import datetime
from databases.database import attendance_collection, employee_collection
from core.security import get_current_user, require_admin_or_user
from schemas.attendance_schema import Attendance, AttendanceStatus
from schemas.token_schema import TokenPayload
from typing import List
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/attendance", tags=["Attendance"])

@router.post("/checkin")
async def check_in(current_user: TokenPayload = Depends(require_admin_or_user)):
    return await attendance_service.check_in(current_user)

@router.post("/checkout")
async def check_out(current_user: TokenPayload = Depends(require_admin_or_user)):
    return await attendance_service.check_out(current_user)

@router.post("/breakin")
async def break_in(current_user: TokenPayload = Depends(require_admin_or_user)):
    return await attendance_service.break_in(current_user)

@router.post("/breakout")
async def break_out(current_user: TokenPayload = Depends(require_admin_or_user)):
    return await attendance_service.break_out(current_user)

@router.get("/logs/me")
async def get_my_logs(current_user: TokenPayload = Depends(require_admin_or_user)):
    return await attendance_service.get_my_logs(current_user)


# services/attendance_service.py
from fastapi import HTTPException
from datetime import datetime
from databases.database import attendance_collection, employee_collection
from schemas.attendance_schema import AttendanceStatus, Attendance

async def check_in(current_user):
    today = datetime.now().date()
    record = await attendance_collection.find_one({
        "user_id": current_user.user_id,
        "check_in": {"$gte": datetime(today.year, today.month, today.day)}
    })
    if record:
        raise HTTPException(status_code=400, detail="Already checked in today")
    await attendance_collection.insert_one({
        "user_id": current_user.user_id,
        "check_in": datetime.now(),
        "check_out": None,
        "break_in": None,
        "break_out": None,
        "status": AttendanceStatus.PRESENT,
        "total_hours": None
    })
    return {"message": "Check-in successful"}

async def check_out(current_user):
    now = datetime.now()
    record = await attendance_collection.find_one({
        "user_id": current_user.user_id,
        "check_out": None
    })
    if not record:
        raise HTTPException(status_code=404, detail="No active check-in")
    check_in = record["check_in"]
    break_in = record.get("break_in")
    break_out = record.get("break_out")
    total_hours = (now - check_in).total_seconds() / 3600
    if break_in and break_out:
        break_duration = (break_out - break_in).total_seconds() / 3600
        total_hours -= break_duration
    await attendance_collection.update_one(
        {"_id": record["_id"]},
        {"$set": {
            "check_out": now,
            "total_hours": round(total_hours, 2),
            "status": AttendanceStatus.PRESENT
        }}
    )
    return {"message": "Check-out successful"}

async def break_in(current_user):
    record = await attendance_collection.find_one({
        "user_id": current_user.user_id,
        "check_out": None,
        "break_in": None
    })
    if not record or record.get("break_out"):
        raise HTTPException(status_code=400, detail="Cannot start break or break already in progress")
    await attendance_collection.update_one(
        {"_id": record["_id"]},
        {"$set": {"break_in": datetime.now()}}
    )
    return {"message": "Break-in successful"}

async def break_out(current_user):
    record = await attendance_collection.find_one({
        "user_id": current_user.user_id,
        "check_out": None,
        "break_in": {"$ne": None},
        "break_out": None
    })
    if not record:
        raise HTTPException(status_code=400, detail="No active break to end")
    await attendance_collection.update_one(
        {"_id": record["_id"]},
        {"$set": {"break_out": datetime.now()}}
    )
    return {"message": "Break-out successful"}

async def get_my_logs(current_user):
    logs = await attendance_collection.find({"user_id": current_user.user_id}).to_list(length=100)
    if not logs:
        return {"logs": []}
    employee = await employee_collection.find_one({"user_id": current_user.user_id})
    employee_name = employee.get("name", "Unknown") if employee else "Unknown"
    processed_logs = []
    for log in logs:
        log_dict = {
            "id": str(log["_id"]),
            "user_id": log["user_id"],
            "check_in": log.get("check_in"),
            "check_out": log.get("check_out"),
            "break_in": log.get("break_in"),
            "break_out": log.get("break_out"),
            "status": log.get("status", AttendanceStatus.NOT_MARKED),
            "total_hours": log.get("total_hours"),
            "employee_name": employee_name
        }
        processed_logs.append(log_dict)
    return {"logs": processed_logs}
